<!DOCTYPE html>
<html>
<head>
	<title>Nine-Tile Cyvasse - Introduction</title>
	<link rel="icon" type="image/png" href="art/favicon.png" />
</head>
<body>

<img id="BRabble" style="display:none" src="art/brabble.png">
<img id="BSpears" style="display:none" src="art/bspears_reverse.png">
<img id="BLightHorse" style="display:none" src="art/blighthorse.png">
<img id="BHeavyHorse" style="display:none" src="art/bheavyhorse.png">
<img id="BElephant" style="display:none" src="art/belephant.png">
<img id="BCrossbows" style="display:none" src="art/bcrossbows.png">
<img id="BTrebuchet" style="display:none" src="art/btrebuchet.png">
<img id="BDragon" style="display:none" src="art/bdragon.png">
<img id="BTower" style="display:none" src="art/btower.png">
<img id="BKing" style="display:none" src="art/bking.png">

<img id="WRabble" style="display:none" src="art/wrabble.png">
<img id="WSpears" style="display:none" src="art/wspears.png">
<img id="WLightHorse" style="display:none" src="art/wlighthorse.png">
<img id="WHeavyHorse" style="display:none" src="art/wheavyhorse.png">
<img id="WElephant" style="display:none" src="art/welephant.png">
<img id="WCrossbows" style="display:none" src="art/wcrossbows.png">
<img id="WTrebuchet" style="display:none" src="art/wtrebuchet.png">
<img id="WDragon" style="display:none" src="art/wdragon.png">
<img id="WTower" style="display:none" src="art/wtower.png">
<img id="WKing" style="display:none" src="art/wking.png">

<div style="height:15px; width:990px; margin:auto; font-family:sans-serif; font-size:14px;">
	<ul style="padding-left:0px; display:inline">
		<li style="display:inline; padding:0.5em"><b>Nine-Tile Cyvasse</b></li>
		<li style="display:inline; padding:0.5em"><a href="index.html">Play</a></li>
		<li style="display:inline; padding:0.5em"><a href="introduction.html">Introduction</a></li>
		<li style="display:inline; padding:0.5em"><a href="cyvasserules.pdf">Rulebook (pdf)</a></li>
	</ul>
</div>

<table id="Table" style="margin:auto; font-family:sans-serif; font-size:14px">
	<tr style="height:490px; vertical-align:top">
		<td id="CanvasCell" style="width:640px">
			<canvas id="Board" width="640" height="490" style="cursor:default">Oops. You broke it.</canvas>
		</td>
		<td style="width:350px">
			<p id="HelpText"></p>
			<table style="margin:auto">
				<tr>
					<td>
						<button id="PreviousButton" style="display:none; width:75px">Previous</button>
						<button id="ResetButton" style="display:none; width:75px">Reset</button>
						<button id="NextButton" style="display:none; width:75px">Next</button>
					</td>
				</tr>
				<tr>
					<p id="MoveCounter" style="font-size:18px"></p>
					<p id="HintText" style="display:none"></p>
				</tr>
			</table>
		</td>
	</tr>
	<tr>
		<td>
			<div style="height:100px width:500px; margin-left:auto; margin-right:auto">
				<table>
					<tr id="PieceInfo" style="display:none">
						<td>
							<img id="PieceInfoImage" />
						</td>
						<td id="PieceInfoText"></td>
					</tr>
					<tr id="MountainInfo" style="display:none">
						<td>
							<canvas id="MountainInfoCanvas" width="40" height="40"></canvas>
						</td>
						<td>
							<b>MOUNTAIN</b><br>Mountain squares block movement and lines of engagement.<br>Pieces cannot be placed on mountain squares.
						</td>
					</tr>
					<tr id="WaterInfo" style="display:none">
						<td>
							<canvas id="WaterInfoCanvas" width="40" height="40"></canvas>
						</td>
						<td>
							<b>WATER</b><br>Pieces that are on water squares cannot engage.
						</td>
					</tr>
				</table>
			</div>
		</td>
	</tr>
</table>

<script>


//Graphics

var ctx = Board.getContext("2d");

var pieceArt = new Array(20);
pieceArt[0] = document.getElementById("WRabble");
pieceArt[1] = document.getElementById("WSpears");
pieceArt[2] = document.getElementById("WLightHorse");
pieceArt[3] = document.getElementById("WHeavyHorse");
pieceArt[4] = document.getElementById("WElephant");
pieceArt[5] = document.getElementById("WCrossbows");
pieceArt[6] = document.getElementById("WTrebuchet");
pieceArt[7] = document.getElementById("WDragon");
pieceArt[8] = document.getElementById("WTower");
pieceArt[9] = document.getElementById("WKing");
pieceArt[10] = document.getElementById("BRabble");
pieceArt[11] = document.getElementById("BSpears");
pieceArt[12] = document.getElementById("BLightHorse");
pieceArt[13] = document.getElementById("BHeavyHorse");
pieceArt[14] = document.getElementById("BElephant");
pieceArt[15] = document.getElementById("BCrossbows");
pieceArt[16] = document.getElementById("BTrebuchet");
pieceArt[17] = document.getElementById("BDragon");
pieceArt[18] = document.getElementById("BTower");
pieceArt[19] = document.getElementById("BKing");

squareSize = 50;
leftMargin = 20;
topMargin = 20;

var showMoves = [];
var showCaptures = [];

var lastFrame = (new Date()).getTime();


//Help Text

pieceText = new Array(10);
pieceText[0] = "<b>RABBLE</b><br>You may move 2 Rabble in the same turn, without capturing.";
pieceText[1] = "<b>SPEARS</b><br>Can only capture and engage forwards.<br>Stops opponent's movement in the two squares directly in front of it.";
pieceText[2] = "<b>LIGHT HORSE</b><br>Moves 3 squares. Can move past pieces it captures.";
pieceText[3] = "<b>HEAVY HORSE</b><br>Heavy. Moves 2 squares. Can move past pieces it captures.";
pieceText[4] = "<b>ELEPHANT</b><br>Heavy. Engagement range 2 squares.<br>Can move 2 squares to capture, but can't move through other pieces.";
pieceText[5] = "<b>CROSSBOWS</b><br>Unarmored. Moves 2 squares. Engagement range 3 squares.<br>Can't capture.";
pieceText[6] = "<b>TREBUCHET</b><br>Unarmored. Engagement range 4 squares, but can't engage adjacent pieces.<br>Captures pieces it's engaging by moving in the opposite direction.";
pieceText[7] = "<b>DRAGON</b><br>Heavy. Moves 4 squares. Engagement range 2 squares.<br>Can move over mountains and opponent's pieces.";
pieceText[8] = "<b>TOWER</b><br>Heavy. Can't move. When a piece is adjacent to an opposing Tower,<br>it can only engage that Tower.";
pieceText[9] = "<b>KING</b><br>Can move to the other side of a Tower of the same color.";

rangelessPieceText = new Array(10);
rangelessPieceText[0] = "<b>RABBLE</b><br>You may move 2 Rabble in the same turn, without capturing.";
rangelessPieceText[1] = "<b>SPEARS</b><br>Can only capture and engage forwards.<br>Stops opponent's movement in the two squares directly in front of it.";
rangelessPieceText[2] = "<b>LIGHT HORSE</b><br>Moves 3 squares. Can move past pieces it captures.";
rangelessPieceText[3] = "<b>HEAVY HORSE</b><br>Heavy. Moves 2 squares. Can move past pieces it captures.";
rangelessPieceText[4] = "<b>ELEPHANT</b><br>Heavy. Can move 2 squares to capture, but can't move through other pieces.";
rangelessPieceText[5] = "<b>CROSSBOWS</b><br>Unarmored. Moves 2 squares. Can't capture.";
rangelessPieceText[6] = "<b>TREBUCHET</b><br>Unarmored. Captures pieces it's engaging by moving in the opposite direction.";
rangelessPieceText[7] = "<b>DRAGON</b><br>Heavy. Moves 4 squares. Can move over mountains and opponent's pieces.";
rangelessPieceText[8] = "<b>TOWER</b><br>Heavy. Can't move. When a piece is adjacent to an opposing Tower,<br>it can only engage that Tower.";
rangelessPieceText[9] = "<b>KING</b><br>Can move to the other side of a Tower of the same color.";

var displayedPiece = null;

function showPieceInfo(piece) {
	displayedPiece = piece;
	if (piece == null) {
		PieceInfo.style.display = "none";
	} else {
		PieceInfoImage.src = pieceArt[piece.type + (10 * piece.color)].src;
		PieceInfoText.innerHTML = (phase >= 4 ? pieceText[piece.type] : rangelessPieceText[piece.type]);
		PieceInfo.style.display = "inline";
	}
}

function showTerrainInfo(hex) {
    if (hexInBounds(hex.x, hex.y) && (phase >= 3)) {
        var terrain = board[hexToIndex(hex.x, hex.y)].terrain;
        if (terrain == terType.mountain) {
            MountainInfo.style.display = "inline";
            WaterInfo.style.display = "none";
            return;
        } else if (terrain == terType.water) {
            MountainInfo.style.display = "none";
            WaterInfo.style.display = "inline";
            return;
        }
    }
    MountainInfo.style.display = "none";
    WaterInfo.style.display = "none";
}


//Component Values

terType = {open: 0, water: 1, mountain: 2};

pieceType = {rabble: 0, spears: 1, lightHorse: 2, heavyHorse: 3,
		elephant: 4, crossbows: 5, trebuchet: 6, dragon: 7, tower: 8, king: 9};

pieceArmor =			[1, 1, 1, 2, 2, 0, 0, 2, 2, 1];
pieceMovement =			[1, 1, 3, 2, 1, 2, 1, 4, 0, 1];
pieceRange =			[1, 1, 1, 1, 2, 3, 4, 2, 1, 1];


//Game State

var moveCount = 0;
var moveLimit = 0;

var mode = {current: 0, setup: 0, hotseat: 1, sandbox: 2};

function setMode(newMode) {
	switch(newMode) {
	case mode.hotseat:
		endTurnButton.innerHTML = "End Turn";
		break;
	case mode.sandbox:
		endTurnButton.innerHTML = "Redo";
		break;
	}
	mode.current = newMode;
}

var phase;

function setPhase(newPhase) {

	if (newPhase >= 1) {
		PreviousButton.style.display = "inline";
		ResetButton.style.display = "inline";
		NextButton.style.display = "inline";
	}

	PreviousButton.disabled = newPhase == 1;
	NextButton.disabled = (newPhase == 9) || (newPhase == 1);

	clearBoard();
	targetHex = null;
	moveCount = 0;
	moveLimit = 0;

	if (newPhase != phase) {
		HintText.style.display = "none";
		HintText.innerHTML = "";
	}

	switch(newPhase) {
	case 0:
		HelpText.innerHTML = "Loading...";
		break;
	case 1:
		HelpText.innerHTML = "<b>About The Game</b><br><br>Nine-Tile Cyvasse is a board game similar to chess. Each player has at their disposal a number of pieces, which they take turns to move one at a time. The pieces are of several different types, and each type has its own rules and properties.<br><br>This introduction will teach you the rules of the game through a series of small tasks and puzzles against an opponent who doesn't move their pieces.<br><br><br><b>Basic Movement</b><br><br>Most types of pieces, like this <img src=\"art/wrabble.png\" width=\"20\" height=\"20\"> Rabble, move one square at a time.<br><br><i>Move the Rabble to the circle, then press 'Next'.</i>";
		createPiece(pieceType.rabble, 5, 4, playerColor);
		targetHex = {x: 6, y: 7};
		break;
	case 2:
		HelpText.innerHTML = "<b>Advanced Movement and Obstacles</b><br><br>The <img src=\"art/wlighthorse.png\" width=\"20\" height=\"20\"> Light Horse can move three spaces at a time.<br><br>The <img src=\"art/wtower.png\" width=\"20\" height=\"20\"> Tower cannot move at all.<br><br>The squares marked with an 'X' are <b>mountains</b>, which pieces cannot move onto.<br><br>Pieces of the same color can move through one another's squares.<br><br><i>Move the Light Horse to the circle.</i>";
		createMountainRange();
		board[hexToIndex(5, 3)].terrain = terType.open;
		board[hexToIndex(6, 5)].terrain = terType.mountain;
		createPiece(pieceType.lightHorse, 5, 3, playerColor);
		createPiece(pieceType.tower, 7, 10, !playerColor);
		createPiece(pieceType.tower, 8, 9, playerColor);
		createPiece(pieceType.tower, 10, 10, !playerColor);
		createPiece(pieceType.tower, 5, 8, playerColor);
		createPiece(pieceType.tower, 6, 7, !playerColor);
		createPiece(pieceType.tower, 8, 7, playerColor);
		createPiece(pieceType.tower, 10, 8, playerColor);
		targetHex = {x: 9, y: 11};
		break;
	case 3:
		HelpText.innerHTML = "<b>Properties of Pieces</b><br><br>Mouse over a piece to see its name and special properties.<br><br><br><b>Capturing</b><br><br>Capturing works like normal movement, but the capture must be made <b>along a straight line</b> (i.e. in one of the six directions pictured below).<br><br><img src=\"art/directions.png\"><br><br>When you can make a capture, it will show up as a red dot.<br><br><i>Use the Dragon to capture all the Crossbows.</i>";
		createPiece(pieceType.dragon, 6, 6, playerColor);
		createPiece(pieceType.crossbows, 4, 7, !playerColor);
		createPiece(pieceType.crossbows, 7, 8, !playerColor);
		createPiece(pieceType.crossbows, 5, 4, !playerColor);
		createPiece(pieceType.crossbows, 8, 5, !playerColor);
		createPiece(pieceType.crossbows, 7, 10, !playerColor);
		createPiece(pieceType.crossbows, 5, 2, !playerColor);
		// board[hexToIndex(6, 3)].terrain = terType.mountain;
		// board[hexToIndex(5, 3)].terrain = terType.mountain;
		// board[hexToIndex(6, 9)].terrain = terType.mountain;
		// board[hexToIndex(7, 9)].terrain = terType.mountain;
		break;
	case 4:
		HelpText.innerHTML = "<b>Engagement</b><br><br>Unlike those <b>unarmored</b> Crossbows, most pieces must be <b>engaged</b> before they can be captured.<br><br>Pieces automatically engage any adjcacent opposing piece. You can tell if a peice is being engaged by mousing over it: <b>red arrows</b> will appear to indicate which piece is engaging it.<br><br><i>Use the Light Horse to engage and capture all the Rabble in 4 moves.</i>";
		HintText.innerHTML = "(HINT: The Light Horse has a special property that allows it to \"jump\" over pieces it captures. Each time you capture a Rabble, make sure to land where you can engage another Rabble, so you can capture it immediately next move.)";
		moveLimit = 4;
		createPiece(pieceType.lightHorse, 4, 3, playerColor);
		createPiece(pieceType.rabble, 5, 4, !playerColor);
		createPiece(pieceType.rabble, 8, 7, !playerColor);
		createPiece(pieceType.rabble, 7, 7, !playerColor);
		createPiece(pieceType.rabble, 4, 6, !playerColor);
		break;
	case 5:
		HelpText.innerHTML = "<b>Engagement Range</b><br><br>Some pieces can engage at a distance.<br><br>Crossbows have an <b>engagement range</b> of 3, which means they can engage other pieces up to 3 squares away, <b>along a straight line</b>.<br><br>Mousing over a piece will show its engagement range, represented by yellow arrowheads.<br><br>You do not have to capture using the same piece that is engaging the captured piece.<br><br><i>Capture all the Rabble in 4 moves.</i>";
		HintText.innerHTML = "(HINT: You will only be able to move the Crossbows once. After capturing the first Rabble, try to position the Crossbows where it will engage both the remaining Rabble at the same time.)";
		moveLimit = 4;
		createPiece(pieceType.lightHorse, 4, 3, playerColor);
		createPiece(pieceType.crossbows, 8, 7, playerColor);
		createPiece(pieceType.rabble, 4, 5, !playerColor);
		createPiece(pieceType.rabble, 7, 6, !playerColor);
		createPiece(pieceType.rabble, 7, 8, !playerColor);
		break;
	case 6:
		HelpText.innerHTML = "<b>Heavy Pieces</b><br><br><b>Heavy</b> pieces like the Tower must be engaged by <i>two</i> pieces before they can be captured.<br><br><i>(<b>Unarmored</b> pieces, on the other hand, do not need to be engaged at all.)</i><br><br>Mousing over a piece will show you how many pieces are engaging it&#8212if it can be captured, the information will show up in red.<br><br>The gray squares are <b>water</b>. Pieces in water cannot engage at all.<br><br><i>Capture both Towers in 3 moves.</i>";
		HintText.innerHTML = "(HINT: Try to position the right Crossbows so that it's engaging both Towers.)";
		createPiece(pieceType.crossbows, 4, 3, playerColor);
		createPiece(pieceType.crossbows, 7, 8, playerColor);
		createPiece(pieceType.heavyHorse, 7, 6, playerColor);
		createPiece(pieceType.tower, 4, 6, !playerColor);
		createPiece(pieceType.tower, 6, 6, !playerColor);
		board[hexToIndex(4, 4)].terrain = terType.water;
		board[hexToIndex(4, 5)].terrain = terType.water;
		board[hexToIndex(4, 6)].terrain = terType.water;
		board[hexToIndex(5, 6)].terrain = terType.water;
		board[hexToIndex(5, 7)].terrain = terType.water;
		moveLimit = 3;
		break;
	case 7:
		HelpText.innerHTML = "<b>Obstructing Lines of Engagement</b><br><br>Lines of engagement cannont pass over mountains. They also cannot pass over enemy pieces.<br><br>For example, the leftmost Tower is not engaged by the Crossbows because the line of engagement is blocked by the Tower to its right.<br><br><i>Capture all the Towers in 5 moves.</i>";
		HintText.innerHTML = "(HINT: Once you move the Rabble into the water, it won't be able to engage anymore. Therefore, you should capture the Tower on the water square last.)";
		moveLimit = 5;
		board[hexToIndex(4, 5)].terrain = terType.mountain;
		board[hexToIndex(5, 6)].terrain = terType.mountain;
		board[hexToIndex(4, 3)].terrain = terType.water;
		createPiece(pieceType.rabble, 5, 3, playerColor);
		createPiece(pieceType.crossbows, 5, 7, playerColor);
		createPiece(pieceType.crossbows, 7, 6, playerColor);
		createPiece(pieceType.tower, 4, 3, !playerColor);
		createPiece(pieceType.tower, 4, 4, !playerColor);
		createPiece(pieceType.tower, 5, 4, !playerColor);
		createPiece(pieceType.tower, 5, 5, !playerColor);
		break;
	case 8:
		HelpText.innerHTML = "<b>Spears</b><br><br>Spears can only engage and capture forwards.<br><br>Any piece that enters a square directly in front of an opposing Spears must end its movement in that square. Blue octagons indicate spaces where a piece is stopped by an enemy Spears.<br><br><i>Capture all the Spears in 6 moves.</i>";
		moveLimit = 6;
		createPiece(pieceType.spears, 3, 5, !playerColor);
		createPiece(pieceType.spears, 5, 7, !playerColor);
		createPiece(pieceType.spears, 6, 8, !playerColor);
		createPiece(pieceType.spears, 7, 7, !playerColor);
		createPiece(pieceType.lightHorse, 5, 5, playerColor);
		createPiece(pieceType.crossbows, 3, 2, playerColor);
		createPiece(pieceType.spears, 6, 5, playerColor);
		createPiece(pieceType.spears, 7, 8, playerColor);
		break;
	case 9:
		HelpText.innerHTML = "<b>Winning</b><br><br>The object of the game is to capture your opponent's King. See if you can do it in 7 moves.<br><br>You have some new pieces in play. Mouse over them to see how they work.<br><br>When you're finished, you can play <a href=\"game.html\">here</a>.";
		HintText.innerHTML = "(HINT: you've seen Towers before, but this time it's important to note that they prevent adjacent enemy pieces from engaging other pieces. You may need to capture one of the Towers before going after the King.)";
		moveLimit = 7;
		createPiece(pieceType.heavyHorse, 4, 2, playerColor);
		createPiece(pieceType.elephant, 7, 5, playerColor);
		createPiece(pieceType.trebuchet, 7, 6, playerColor);
		createPiece(pieceType.king, 6, 5, playerColor);
		createPiece(pieceType.tower, 6, 4, playerColor);
		createPiece(pieceType.rabble, 4, 4, !playerColor);
		createPiece(pieceType.rabble, 5, 5, !playerColor);
		board[hexToIndex(6, 6)].terrain = terType.water;
		createPiece(pieceType.rabble, 7, 7, !playerColor);
		createPiece(pieceType.tower, 3, 5, !playerColor);
		createPiece(pieceType.tower, 6, 8, !playerColor);
		createPiece(pieceType.spears, 4, 6, !playerColor);
		createPiece(pieceType.spears, 5, 7, !playerColor);
		createPiece(pieceType.king, 4, 7, !playerColor);
		board[hexToIndex(3, 7)].terrain = terType.mountain;
		board[hexToIndex(4, 8)].terrain = terType.mountain;
        localStorage.newPlayer = false;
		break;
	}
	phase = newPhase;
	draw();
	updateMoveCounter();
}

var board = new Array(88);
for (var i = 0; i < 88; ++i) {
	board[i] = {piece: null, terrain: terType.open};
}

var targetHex = null;

var playerColor = false;
var topColor = true;

var playerPieces = [];

var opponentPieces = [];


//Mouse Info

var mouseX = 0;
var mouseY = 0;
var mouseDown = false;
var movingPiece = null;
var movingPieceX = 0;
var movingPieceY = 0;
var grabX = 0;
var grabY = 0;
var moved = false;


//Misc Utilities

function containsHex(array, x, y) {
	for (var i = 0; i < array.length; ++i) {
		if ((array[i].x == x) && (array[i].y == y)) {
			return true;
		}
	}
	return false;
}

function getItemAtHex(array, x, y) {
	for (var i = 0; i < array.length; ++i) {
		if ((array[i].x == x) && (array[i].y == y)) {
			return array[i];
		}
	}
	return null;
}

function playerOwns(piece) {
	return piece.color == playerColor;
}


//Board Math

function updateMousePos(event) {
	mouseX = (event.clientX + document.body.scrollLeft) - (Table.offsetLeft + CanvasCell.offsetLeft + Board.offsetLeft);
	mouseY = (event.clientY + document.body.scrollTop) - (Table.offsetTop + CanvasCell.offsetTop + Board.offsetTop);
}

var unitMoves = [{x: 1, y: 1},
                {x: 1, y: 0},
                {x: 0, y: -1},
                {x: -1, y: -1},
                {x: -1, y: 0},
                {x: 0, y: 1}];

function sumPos(left, right) {
    return {x: left.x + right.x, y: left.y + right.y};
}

function hexInBounds(x, y) {
	return (Math.abs(x - y) < 5) &&
		(x >= 0) &&
		(x < 12) &&
		(y >= 0) &&
		(y < 12);
}

function hexPosX(x, y) {
	return ((x + y) * (squareSize / 2)) + leftMargin;
}

function hexPosY(x, y) {
	return ((4 - (y - x)) * squareSize) + topMargin;
}

function hexPos(x, y) {
	return {x: ((x + y) * (squareSize / 2)) + leftMargin,
			y: ((4 - (y - x)) * squareSize) + topMargin};
}

function hexAtPos(x, y) {
	var tileY = Math.floor((y - topMargin) / squareSize);
	var offset = (4 - tileY) * (squareSize/2);
	var tileX = Math.floor(((x - offset) - leftMargin) / squareSize);
	return {x: tileX, y: tileX + (4 - tileY)};
}

function hexToIndex(x, y) {
	switch(x - y + 4) {
	case 0:
		return x - 0;
	case 1:
		return x + 8;
	case 2:
		return x + 17;
	case 3:
		return x + 27;
	case 4:
		return x + 38;
	case 5:
		return x + 49;
	case 6:
		return x + 59;
	case 7:
		return x + 68;
	case 8:
		return x + 76;
	}
}

function indexToHex(i) {
	var hex = {x: -1, y: -1};
	if ((i >= 0) && (i < 8)) {
		hex.x = i;
		hex.y = i + 4;
	} else if (i < 17) {
		hex.x = i - 8;
		hex.y = i - 5;
	} else if (i < 27) {
		hex.x = i - 17;
		hex.y = i - 15;
	} else if (i < 38) {
		hex.x = i - 27;
		hex.y = i - 26;
	} else if (i < 50) {
		hex.x = i - 38;
		hex.y = i - 38;
	} else if (i < 61) {
		hex.x = i - 49;
		hex.y = i - 50;
	} else if (i < 71) {
		hex.x = i - 59;
		hex.y = i - 61;
	} else if (i < 80) {
		hex.x = i - 68;
		hex.y = i - 71;
	} else if (i < 88) {
		hex.x = i - 76;
		hex.y = i - 80;
	}
	return hex;
}

function posInBounds(x, y, boundX, boundY, width, height) {
	return (x > boundX) && (x < boundX + width) && (y > boundY) && (y < boundY + height);
}

function distance(x1, y1, x2, y2) {
	return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

function hexDistance(x1, y1, x2, y2) {
	var dx = x1 - x2;
	var dy = y1 - y2;
	if ((dx * dy) > 0) {
        return (Math.abs(dx + dy) + Math.abs(dx - dy)) / 2;
    } else {
        return Math.abs(dx - dy);
    }
}


//Draw Functions
function drawTerrainThumbails() {

    var left = 2;
    var right = MountainInfoCanvas.width - left;
    var top = 2;
    var bottom = MountainInfoCanvas.height - top;
    var width = right - left;
    var height = bottom - top;

    var mctx = MountainInfoCanvas.getContext("2d");
    mctx.clearRect(0, 0, MountainInfoCanvas.width, MountainInfoCanvas.height);
    mctx.beginPath();
    mctx.lineWidth = 2;
    mctx.strokeStyle = "#000000";
    mctx.fillStyle = "#FFFFFF";
    mctx.fillRect(left, top, width, height);
    mctx.rect(left, top, width, height);
    mctx.moveTo(left, top);
    mctx.lineTo(right, bottom);
    mctx.moveTo(right, top);
    mctx.lineTo(left, bottom);
    mctx.stroke();

    var wctx = WaterInfoCanvas.getContext("2d");
    wctx.clearRect(0, 0, WaterInfoCanvas.width, WaterInfoCanvas.height);
    wctx.beginPath();
    wctx.lineWidth = 2;
    wctx.strokeStyle = "#000000";
    wctx.fillStyle = "#C0C0C0";
    wctx.fillRect(left, top, width, height);
    wctx.rect(left, top, width, height);
    wctx.stroke();
}

function drawSquare(x, y, terrain) {
	ctx.beginPath();
	ctx.lineWidth = 2;
	ctx.strokeStyle = "#000000";
	if (terrain == terType.water) {
		ctx.fillStyle = "#C0C0C0";
	} else {
		ctx.fillStyle = "#FFFFFF";
	}
	ctx.rect(x, y, squareSize, squareSize);
	ctx.fillRect(x, y, squareSize, squareSize);
	if (terrain == terType.mountain) {
		ctx.moveTo(x,y);
		ctx.lineTo(x + squareSize, y + squareSize);
		ctx.moveTo(x + squareSize, y);
		ctx.lineTo(x, y + squareSize);
	}
	ctx.stroke();
}

function drawBoard() {
	for (var i = 0; i < 88; ++i) {
		var hex = indexToHex(i);
		var pos = hexPos(hex.x, hex.y);
		drawSquare(pos.x, pos.y, board[i].terrain);
	}
}

function drawTargetMarker() {
	if (targetHex != null) {
		ctx.beginPath();
		ctx.lineWidth = 2;
		ctx.strokeStyle = "#000000";
		var x = hexPosX(targetHex.x, targetHex.y) + squareSize/2;
		var y = hexPosY(targetHex.x, targetHex.y) + squareSize/2;
		ctx.arc(x, y, squareSize/6, 0, 2*Math.PI);
		ctx.stroke();
	}
}

function drawPiece(piece) {
	ctx.beginPath();
	ctx.lineWidth = 1.5;
	ctx.strokeStyle = "#000000";
	ctx.fillStyle = "#FFFFFF";
	var x = 0;
	var y = 0;
	if (piece == movingPiece) {
		x = movingPieceX;
		y = movingPieceY;
	} else {
		var pos = hexPos(piece.x, piece.y);
		x = pos.x + squareSize/2;
		y = pos.y + squareSize/2;
	}
	var radius = (2/5) * squareSize;
	var artIndex = piece.type + (piece.color * 10);
	if (squareSize == 50) {
		ctx.drawImage(pieceArt[artIndex], x - radius - 1, y - radius - 1);
	} else {
		ctx.drawImage(pieceArt[artIndex], x - radius, y - radius, 2 * radius, 2 * radius);
	}
}

const twiceRootThree = 2 * Math.sqrt(3);

function traceLeftArrowHead(x, y) {
	ctx.moveTo(x - 4, y);
	ctx.lineTo(x + 2, y + twiceRootThree);
	ctx.lineTo(x + 2, y - twiceRootThree);
	ctx.lineTo(x - 4, y);
	ctx.closePath();
}

function traceRightArrowHead(x, y) {
	ctx.moveTo(x + 4, y);
	ctx.lineTo(x - 2, y + twiceRootThree);
	ctx.lineTo(x - 2, y - twiceRootThree);
	ctx.lineTo(x + 4, y);
	ctx.closePath();
}

function drawEngagementLine(engager, engaged, red) {
	var engagerPos = hexPos(engager.x, engager.y);
	var engagedPos = hexPos(engaged.x, engaged.y);
	var dist = distance(engagerPos.x, engagerPos.y, engagedPos.x, engagedPos.y);
	var endPointX = engagedPos.x + squareSize/2 + ((2/5) * squareSize * (engagerPos.x - engagedPos.x) / dist);
	var endPointY = engagedPos.y + squareSize/2 + ((2/5) * squareSize * (engagerPos.y - engagedPos.y) / dist);

	var traceArrowHead;
	if ((engagerPos.x < engagedPos.x) != (engagerPos.y == engagedPos.y)) {
		traceArrowHead = traceLeftArrowHead;
	} else {
		traceArrowHead = traceRightArrowHead;
	}

	ctx.beginPath();
	ctx.lineWidth = 4;
	ctx.strokeStyle = "#000000";
	ctx.moveTo(engagerPos.x + squareSize/2, engagerPos.y + squareSize/2);
	ctx.lineTo(endPointX, endPointY);
	traceArrowHead(endPointX, endPointY);
	ctx.stroke();

	ctx.beginPath();
	ctx.lineWidth = 2;
	ctx.strokeStyle = (red ? "#FF0000" : "#FFFFFF");
	ctx.fillStyle = ctx.strokeStyle;
	ctx.moveTo(engagerPos.x + squareSize/2, engagerPos.y + squareSize/2);
	ctx.lineTo(endPointX, endPointY);
	traceArrowHead(endPointX, endPointY);
	ctx.stroke();
	ctx.fill();
}

function drawRangeMarker(piece, marker) {
    var x = hexPosX(marker.x, marker.y) + squareSize/2;
    var y = hexPosY(marker.x, marker.y) + squareSize/2;
    if ((piece.x + piece.y > marker.x + marker.y) != (piece.x - piece.y == marker.x - marker.y)) {
        traceArrowHead = traceRightArrowHead;
    } else {
        traceArrowHead = traceLeftArrowHead;
    }
    ctx.beginPath();
    ctx.lineWidth = 4;
    ctx.strokeStyle = "#000000";
    traceArrowHead(x, y);
    ctx.stroke();

    ctx.beginPath();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#F0F0C0";
    ctx.fillStyle = "#F0F0C0";
    traceArrowHead(x, y);
    ctx.stroke();
    ctx.fill();
}

function drawEngagement() {
    var piece = pieceUnderMouse();

    if (piece != null) {
        var engagement = getEngagement(piece);
        var rangeMarkers = getRangeMarkers(piece);
        var armor = pieceArmor[piece.type];
        var red = engagement >= armor;

        //draw lines
        for (var i = 0; i < engagers.length; ++i) {
            drawEngagementLine(engagers[i], piece, red);
        }

        //draw engagers over lines
        for (var i = 0; i < engagers.length; ++i) {
            drawPiece(engagers[i]);
        }

        //draw range markers
        if (phase >= 5) {
	        for (var i = 0; i < rangeMarkers.length; ++i) {
	            drawRangeMarker(piece, rangeMarkers[i]);
	        }
	    }

		//draw numbers
		if (phase >= 6) {
			ctx.beginPath();
			ctx.lineWidth = 3;
			if (phase == 6) {
				ctx.font = "bold 16px sans-serif"
			} else {
				ctx.font = "bold 14px sans-serif"
			}
			ctx.textAlign = "center";
			ctx.strokeStyle = "#000000";
			ctx.fillStyle = (red ? "#FF0000" : "#FFFFFF");
			var text = engagement + "/" + armor;
			var x = hexPosX(piece.x, piece.y) + squareSize/2;
			var y = hexPosY(piece.x, piece.y) + squareSize;
			ctx.strokeText(text, x, y);
			ctx.fillText(text, x, y);
			ctx.stroke();
		}
	}
}

function drawMoveDot(x, y, color) {
    ctx.beginPath();
    //ctx.lineWidth = 1.5;
    //ctx.strokeStyle = "#000000";
    ctx.fillStyle = color;
    var xPos = hexPosX(x, y) + squareSize/2;
    var yPos = hexPosY(x, y) + squareSize/2;
    ctx.moveTo(xPos + squareSize/6, yPos);
    ctx.arc(xPos, yPos, squareSize/6, 0, 2*Math.PI);
    ctx.fill();
    //ctx.stroke();
}

function drawMoveOctagon(x, y, color) {
    ctx.beginPath();
    //ctx.lineWidth = 1.5;
    //ctx.strokeStyle = "#000000";
    ctx.fillStyle = color;
    var xPos = hexPosX(x, y) + squareSize/2;
    var yPos = hexPosY(x, y) + squareSize/2;
    // ctx.moveTo(xPos - squareSize/15, yPos - squareSize/6);
    // ctx.lineTo(xPos + squareSize/15, yPos - squareSize/6);
    // ctx.lineTo(xPos + squareSize/6, yPos - squareSize/15);
    // ctx.lineTo(xPos + squareSize/6, yPos + squareSize/15);
    // ctx.lineTo(xPos + squareSize/15, yPos + squareSize/6);
    // ctx.lineTo(xPos - squareSize/15, yPos + squareSize/6);
    // ctx.lineTo(xPos - squareSize/6, yPos + squareSize/15);
    // ctx.lineTo(xPos - squareSize/6, yPos - squareSize/15);
    // ctx.lineTo(xPos - squareSize/15, yPos - squareSize/6);
    ctx.moveTo(xPos - squareSize/12, yPos - squareSize/5);
    ctx.lineTo(xPos + squareSize/12, yPos - squareSize/5);
    ctx.lineTo(xPos + squareSize/5, yPos - squareSize/12);
    ctx.lineTo(xPos + squareSize/5, yPos + squareSize/12);
    ctx.lineTo(xPos + squareSize/12, yPos + squareSize/5);
    ctx.lineTo(xPos - squareSize/12, yPos + squareSize/5);
    ctx.lineTo(xPos - squareSize/5, yPos + squareSize/12);
    ctx.lineTo(xPos - squareSize/5, yPos - squareSize/12);
    ctx.lineTo(xPos - squareSize/12, yPos - squareSize/5);
    ctx.fill();
}

function drawMoves() {
    if ((showMoves != []) || (showCaptures != [])) {
        var spearblocks = getSpearBlocks(movingPiece != null);
        for (var i = 0; i < showMoves.length; ++i) {
            var hex = showMoves[i];
            if (!containsHex(showCaptures, hex.x, hex.y)) {
                if (containsHex(spearblocks, hex.x, hex.y)) {
                    drawMoveOctagon(hex.x, hex.y, "#0000FF");
                } else {
                    drawMoveDot(hex.x, hex.y, "#0000FF");
                }
            }
        }
        for (var i = 0; i < showCaptures.length; ++i) {
            hex = showCaptures[i];
    		ctx.beginPath();
        	ctx.lineWidth = 4;
        	ctx.strokeStyle = "#FF0000";
        	ctx.moveTo(hexPosX(movingPiece.x, movingPiece.y) + squareSize/2, hexPosY(movingPiece.x, movingPiece.y) + squareSize/2);
        	ctx.lineTo(hexPosX(hex.x, hex.y) + squareSize/2, hexPosY(hex.x, hex.y) + squareSize/2);
        	ctx.stroke();      	
            if (containsHex(spearblocks, hex.x, hex.y)) {
                drawMoveOctagon(hex.x, hex.y, "#FF0000");
            } else {
                drawMoveDot(hex.x, hex.y, "#FF0000");
            }
        }
    }
}

function draw() {
	ctx.clearRect(0, 0, Board.width, Board.height);
	drawBoard();
	drawTargetMarker();
	for (var i = 0; i < opponentPieces.length; ++i) {
		drawPiece(opponentPieces[i]);
	}
	for (var i = 0; i < playerPieces.length; ++i) {
		drawPiece(playerPieces[i]);
	}
	drawMoves();
	if (mouseDown) {
		if (movingPiece != null) {
			drawPiece(movingPiece);
		}
	} else if (phase >= 4) {
		drawEngagement();
	}
}


//Game Logic

function adjacencies(x, y) {
	var adjacencies = new Array();
	if (hexInBounds(x + 1, y)) {
		adjacencies.push({x: x + 1, y: y})
	}
	if (hexInBounds(x + 1, y + 1)) {
		adjacencies.push({x: x + 1, y: y + 1})
	}
	if (hexInBounds(x, y + 1)) {
		adjacencies.push({x: x, y: y + 1})
	}
	if (hexInBounds(x - 1, y)) {
		adjacencies.push({x: x - 1, y: y})
	}
	if (hexInBounds(x - 1, y -1)) {
		adjacencies.push({x: x - 1, y: y - 1})
	}
	if (hexInBounds(x, y - 1)) {
		adjacencies.push({x: x, y: y - 1})
	}
	return adjacencies;
}

function straightPathTo(origin, target, range, blocked) {
	if (origin.x == target.x) {
		if (Math.abs(origin.y - target.y) > range) {
			return false;
		} 
		var x = origin.x
		for (var y = Math.min(origin.y, target.y) + 1; y <= Math.max(origin.y, target.y); ++y) {
			var square = board[hexToIndex(x, y)];
			if ((square.piece == target) || (square.piece == origin)) {
				return true;
			} else if (blocked(square, x, y)) {
				return false;
			}
		}
	} else if (origin.y == target.y) {
		if (Math.abs(origin.x - target.x) > range) {
			return false;
		} 
		var y = origin.y
		for (var x = Math.min(origin.x, target.x) + 1; x <= Math.max(origin.x, target.x); ++x) {
			var square = board[hexToIndex(x, y)];
			if ((square.piece == target) || (square.piece == origin)) {
				return true;
			} else if (blocked(square, x, y)) {
				return false;
			}
		}
	} else if (origin.x - origin.y == target.x - target.y) {
		if (Math.abs(origin.y - target.y) > range) {
			return false;
		} 
		var diff = origin.x - origin.y
		for (var y = Math.min(origin.y + 1, target.y + 1); y <= Math.max(origin.y, target.y); ++y) {
			var x = y + diff;
			var square = board[hexToIndex(x, y)];
			if ((square.piece == target) || (square.piece == origin)) {
				return true;
			} else if (blocked(square, x, y)) {
				return false;
			}
		}
	}
	return false;
}

function lineOfSight(origin, target, range) {
	function blocked(square, x, y) {
		return ((square.terrain == terType.mountain) ||
				((square.piece != null) && (square.piece.color != origin.color)));
	}
	return straightPathTo(origin, target, range, blocked);
}

function getSpearBlocks(player) {
	var blocks = new Array();
	var pieces = (player ? opponentPieces : playerPieces);
	for (var i = 0; i < pieces.length; ++i) {
		var piece = pieces[i];
		if (piece.type == pieceType.spears) {
			if (piece.color == topColor) {
				blocks.push({x: piece.x + 1, y: piece.y});
				blocks.push({x: piece.x, y: piece.y - 1});
			} else {
				blocks.push({x: piece.x - 1, y: piece.y});
				blocks.push({x: piece.x, y: piece.y + 1});
			}
		}
	}
	return blocks;
}

function lineOfAttack(origin, target, range) {
	var spearBlocks = getSpearBlocks(playerOwns(origin));
	function blocked(square, x, y) {
		return ((square.terrain == terType.mountain) ||
				((square.piece != null) && (square.piece.color != origin.color)) ||
				(containsHex(spearBlocks, x, y)));
	}
	return straightPathTo(origin, target, range, blocked);
}

function lineOfFlight(origin, target, range) {
	var spearBlocks = getSpearBlocks(playerOwns(origin));
	function blocked(square, x, y) {
		return (containsHex(spearBlocks, x, y));
	}
	return straightPathTo(origin, target, range, blocked);
}

function lineOfCharge(origin, target, range) {
	var spearBlocks = getSpearBlocks(playerOwns(origin));
	function blocked(square, x, y) {
		return ((square.terrain == terType.mountain) ||
				(square.piece != null) ||
				(containsHex(spearBlocks, x, y)));
	}
	return straightPathTo(origin, target, range, blocked);
}

function lineOfSpear(origin, target) {
	if (origin.color == topColor) {
		return (((target.x == origin.x + 1) && (target.y == origin.y)) ||
				((target.x == origin.x) && (target.y == origin.y - 1)));
	} else {
		return (((target.x == origin.x - 1) && (target.y == origin.y)) ||
				((target.x == origin.x) && (target.y == origin.y + 1)));
	}
}

function getAdjacentEnemyTowers(piece) {
    var towers = [];
    var adj = adjacencies(piece.x, piece.y);
    for (var i = 0; i < adj.length; ++i) {
        var hex = adj[i];
        var square = board[hexToIndex(hex.x, hex.y)];
        if ((square.piece != null) &&
                (square.piece.type == pieceType.tower) &&
                (square.piece.color != piece.color)) {
            towers.push(square.piece);
        }
    }
    return towers;
}

function engages(engager, engaged) {
	if (engager.color == engaged.color) {
		return false;
	}
	if (board[hexToIndex(engager.x, engager.y)].terrain == terType.water) {
		return false;
	}
	var range = pieceRange[engager.type];

	//special case for a piece next to an enemy tower
	var adj = adjacencies(engager.x, engager.y)
	for (var i = 0; i < adj.length; ++i) {
		var hex = adj[i];
		var square = board[hexToIndex(hex.x, hex.y)];
		if ((square.piece != null) &&
				(square.piece.type == pieceType.tower) &&
				(square.piece.color != engager.color)) {
			if (engaged.type != pieceType.tower) {
				return false;
			} else {
				range = 1;
			}
		}
	}

	if (engager.type == pieceType.spears) {
		return lineOfSpear(engager, engaged, range);
    } else if ((engager.type == pieceType.trebuchet) && (distance(engager.x, engager.y, engaged.x, engaged.y) == 1)) {
        return false;
	} else {
		return lineOfSight(engager, engaged, range);
	}
}

function getRangeMarkers(piece) {
    var markers = [];
    var range = pieceRange[piece.type];
    if (board[hexToIndex(piece.x, piece.y)].terrain != terType.water) {
    	if (piece.type == pieceType.spears) {
    		if (piece.color == topColor) {
	    		markers.push({x: piece.x + 1, y: piece.y});
	    		markers.push({x: piece.x, y: piece.y - 1});
	    	} else {
	    		markers.push({x: piece.x - 1, y: piece.y});
	    		markers.push({x: piece.x, y: piece.y + 1});
	    	}
	    	return markers;
    	}
        var adjTowers = getAdjacentEnemyTowers(piece);
        if (adjTowers.length > 0) {
            return adjTowers;
        }
        for (var direction = 0; direction < 6; ++direction) {
            var pos = {x: piece.x, y: piece.y};
            for (var distance = 0; distance < range; ++distance) {
                var otherPiece = board[hexToIndex(pos.x, pos.y)].piece;
                if ((otherPiece != null) && (otherPiece.color != piece.color)) {
                    break;
                }
                var nextPos = sumPos(pos, unitMoves[direction]);
                if ((!hexInBounds(nextPos.x, nextPos.y)) || (board[hexToIndex(nextPos.x, nextPos.y)].terrain == terType.mountain)) {
                    break;
                }
                pos = nextPos;
	            if ((piece.type != pieceType.trebuchet) || (distance > 0)) {
	                markers.push(pos);
	            }
            }
        }
    }
    return markers;
}

var engagers = new Array();

function getEngagement(piece) {
	var engagement = 0;
	engagers = new Array();
	if (playerOwns(piece)) {
		for (var i = 0; i < opponentPieces.length; ++i) {
			var enemyPiece = opponentPieces[i];
			if (engages(enemyPiece, piece)) {
				++engagement;
				engagers.push(enemyPiece);
			}
		}
	} else {
		for (var i = 0; i < playerPieces.length; ++i) {
			var enemyPiece = playerPieces[i];
			if (engages(enemyPiece, piece)) {
				++engagement;
				engagers.push(enemyPiece);
			}
		}
	}
	return engagement;
}

function fullyEngaged(piece) {
	return getEngagement(piece) >= pieceArmor[piece.type];
}

function breachCaptures(piece, captures) {
	var range = pieceMovement[piece.type];
	var spearBlocks = getSpearBlocks(playerOwns(piece));
	for (var i = 0; i < captures.length; ++i) {
		var x = captures[i].x;
		var y = captures[i].y;
		if (containsHex(spearBlocks, x, y)) { continue; }
		var distance = hexDistance(piece.x, piece.y, x, y);
		var dx = (x - piece.x) / distance;
		var dy = (y - piece.y) / distance;
		for (var d = distance; d < range; ++d) {
			x += dx;
			y += dy;
			var square = board[hexToIndex(x, y)];
			if (!hexInBounds(x, y) ||
					(square.piece != null) ||
					(square.terrain == terType.mountain)) {
				break;
			}
			captures.push({x: x, y: y, captured: captures[i].captured});
			if (containsHex(spearBlocks, x, y)) { break; }
		}
	}
	return captures;
}

function rangedCaptures(piece, captures) {
	var rangedCaptures = new Array();
	if (board[hexToIndex(piece.x, piece.y)].terrain == terType.water) { return rangedCaptures; }
	for (var i = 0; i < captures.length; ++i) {
		var distance = hexDistance(piece.x, piece.y, captures[i].x, captures[i].y);
		if (distance > 1) {
			var x = piece.x - ((captures[i].x - piece.x) / distance);
			var y = piece.y - ((captures[i].y - piece.y) / distance);
			var square = board[hexToIndex(x, y)];
			if ((hexInBounds(x, y)) && (square.piece == null) && (square.terrain != terType.mountain)) {
				rangedCaptures.push({x: x, y: y, captured: captures[i].captured});
			}
		}
	}
	return rangedCaptures;
}

function getCaptures(piece) {

	var captures = new Array();
	var range = pieceMovement[piece.type];
	var checkPath = lineOfAttack;
	var enemyPieces = (playerOwns(piece) ? opponentPieces : playerPieces);

	if (piece.type == pieceType.crossbows) {
		return captures;
	} else if (piece.type == pieceType.spears) {
		checkPath = lineOfSpear;
	} else if (piece.type == pieceType.dragon) {
		checkPath = lineOfFlight;
	} else if (piece.type == pieceType.elephant) {
		checkPath = lineOfCharge;
		range = 2;
	} else if (piece.type == pieceType.trebuchet) {
		checkPath = lineOfSight;
		range = 4;
	}

	for (var i = 0; i < enemyPieces.length; ++i) {
		var enemyPiece = enemyPieces[i];
		if (fullyEngaged(enemyPiece) && checkPath(piece, enemyPiece, range)) {
			captures.push({x: enemyPiece.x, y: enemyPiece.y, captured: enemyPiece});
		}
	}

	if ((piece.type == pieceType.lightHorse) || (piece.type == pieceType.heavyHorse)) {
		captures = breachCaptures(piece, captures);
	} else if (piece.type == pieceType.trebuchet) {
		captures = rangedCaptures(piece, captures);
	}
	return captures;
}

function getMovesFrom(x, y, distance, type, color, moves) {
	var square = board[hexToIndex(x, y)];
	var squareIsOpen = (square.piece == null) && (square.terrain != terType.mountain);
	if ((squareIsOpen) && !(containsHex(moves, x, y))) {
		moves.push({x: x, y: y});
	}
	if (distance < pieceMovement[type]) {
		var spearBlocks = getSpearBlocks(playerPieces);
		if (containsHex(spearBlocks, x, y)) {
			return moves;
		}
	}
	if ((distance != 0) && (squareIsOpen || ((square.piece != null) && (square.piece.color == color)) || (type == pieceType.dragon))) {
		var adj = adjacencies(x, y);
		for (var i = 0; i < adj.length; ++i) {
			moves = getMovesFrom(adj[i].x, adj[i].y, distance - 1, type, color, moves);
		}
	}
	return moves;
}

function getMoves(piece) {

	var moves = getMovesFrom(piece.x, piece.y, pieceMovement[piece.type], piece.type, piece.color, new Array());

	//special case for jumping
	if (piece.type == pieceType.king) {
		var adj = adjacencies(piece.x, piece.y);
		for (var i = 0; i < adj.length; ++i) {
			var square = board[hexToIndex(adj[i].x, adj[i].y)];
			if ((square.piece != null) && (square.piece.type == pieceType.tower) && (square.piece.color == piece.color)) {
				var x = (2 * adj[i].x) - piece.x;
				var y = (2 * adj[i].y) - piece.y;
				var squareBeyond = board[hexToIndex(x, y)];
				if ((hexInBounds(x, y)) && (squareBeyond.piece == null) && (squareBeyond.terrain != terType.mountain)) {
					moves.push({x: x, y: y});
				}
			}
		}
	}

	return moves;
}


//Board Manipulation

function objectiveComplete() {
	if (phase == 9) {
		for (var i = 0; i < opponentPieces.length; ++i) {
			if (opponentPieces[i].type == pieceType.king) {
				return false;
			}
		}
		return true;
	} else {
		return opponentPieces.length == 0;
	}
}

function updateMoveCounter() {
	if (moveLimit > 0) {
		if (moveCount < moveLimit) {
			MoveCounter.innerHTML = (moveLimit - moveCount) + " moves left."
		} else {
			if (objectiveComplete()) {
				MoveCounter.innerHTML = "Success!";
			} else {
				MoveCounter.innerHTML = "<span style=\"color:red\"<b>" + (moveLimit - moveCount) + " moves left. Reset to try again.</b></span>"
				HintText.style.display = "inline";
			}
		}
	} else {
		MoveCounter.innerHTML = "";
	}
}

function executeMove(move) {
	//modify the board and pieces
	var pieces = (move.color == playerColor ? playerPieces : opponentPieces);
	var piece = getItemAtHex(pieces, move.x0, move.y0);
	if (move.capture) {
		var enemyPieces = (move.color == playerColor ? opponentPieces : playerPieces);
		var enemyPiece = getItemAtHex(enemyPieces, move.x2, move.y2);
		enemyPieces.splice(enemyPieces.indexOf(enemyPiece), 1);
		board[hexToIndex(move.x2, move.y2)].piece = null;
	}
	piece.x = move.x1;
	piece.y = move.y1;
	board[hexToIndex(move.x0, move.y0)].piece = null;
	board[hexToIndex(move.x1, move.y1)].piece = piece;
	++moveCount;
	updateMoveCounter();
}

function clearBoard() {
	playerPieces = [];
	opponentPieces = [];
	for (var i = 0; i < 88; ++i) {
		var square = board[i];
		square.terrain = terType.open;
		square.piece = null;
	}
}

function createPiece(type, x, y, color) {
	var piece = {type: type, x: x, y: y, color: color};
	var pieces = (color == playerColor ? playerPieces : opponentPieces);
	pieces.push(piece);
	board[hexToIndex(x, y)].piece = piece;
}

function createMountainRange() {
	board[hexToIndex(1, 5)].terrain = terType.mountain;
	board[hexToIndex(3, 7)].terrain = terType.mountain;
	board[hexToIndex(5, 9)].terrain = terType.mountain;
	board[hexToIndex(7, 11)].terrain = terType.mountain;
	board[hexToIndex(1, 3)].terrain = terType.mountain;
	board[hexToIndex(3, 5)].terrain = terType.mountain;
	board[hexToIndex(5, 7)].terrain = terType.mountain;
	board[hexToIndex(7, 9)].terrain = terType.mountain;
	board[hexToIndex(1, 1)].terrain = terType.mountain;
	board[hexToIndex(3, 3)].terrain = terType.mountain;
	board[hexToIndex(5, 5)].terrain = terType.mountain;
	board[hexToIndex(7, 7)].terrain = terType.mountain;
	board[hexToIndex(9, 9)].terrain = terType.mountain;
	board[hexToIndex(11, 11)].terrain = terType.mountain;
	board[hexToIndex(3, 1)].terrain = terType.mountain;
	board[hexToIndex(5, 3)].terrain = terType.mountain;
	board[hexToIndex(7, 5)].terrain = terType.mountain;
	board[hexToIndex(9, 7)].terrain = terType.mountain;
	board[hexToIndex(11, 9)].terrain = terType.mountain;
	board[hexToIndex(5, 1)].terrain = terType.mountain;
	board[hexToIndex(7, 3)].terrain = terType.mountain;
	board[hexToIndex(9, 5)].terrain = terType.mountain;
	board[hexToIndex(11, 7)].terrain = terType.mountain;
}

//Mouse Input

function pieceUnderMouse() {
	var hex = hexAtPos(mouseX, mouseY);
	if (hexInBounds(hex.x, hex.y)) {
		var piece = board[hexToIndex(hex.x, hex.y)].piece;
		if (piece != null) {
			var centerX = hexPosX(hex.x, hex.y) + squareSize/2;
			var centerY = hexPosY(hex.x, hex.y) + squareSize/2;
			if (distance(mouseX, mouseY, centerX, centerY) <= (2/5) * squareSize) {
				return piece;
			}
		}
	}
	return null;
}

Board.onmousemove = function(event) {
	updateMousePos(event);
	if (!mouseDown) {
		var piece = pieceUnderMouse();
		if (phase >= 3) {
			if (piece != displayedPiece) {
				showPieceInfo(piece);
			}
		}
		if (piece != null) {
			Board.style.cursor = "pointer";
		} else {
			Board.style.cursor = "default";
		}
	}
	if (movingPiece != null) {
		movingPieceX = mouseX - grabX;
		movingPieceY = mouseY - grabY;
	}
	var now = (new Date()).getTime();
	if ((now - lastFrame) > 15) {
		draw();
		lastFrame = now;
	}
    showTerrainInfo(hexAtPos(mouseX, mouseY));
	moved = true;
};

function interpretMove(piece, x, y) {
	var moves = getMoves(piece);
	var captures = getCaptures(piece);
	var move = {x0: piece.x, y0: piece.y, x1: x, y1: y, capture: false, color: piece.color, type: piece.type};
	if (containsHex(captures, x, y)) {
		move.capture = true;
		var captured = getItemAtHex(captures, x, y).captured
		move.capType = captured.type;
		move.x2 = captured.x;
		move.y2 = captured.y;
	} else if (!containsHex(moves, x, y)) {
		return null;
	}
	return move;
}

Board.onmouseup = function() {
	mouseDown = false;
	if (movingPiece != null) {
		var hex = hexAtPos(movingPieceX, movingPieceY);
		var move = interpretMove(movingPiece, hex.x, hex.y);
		if (move != null) {
			executeMove(move);
		}
		movingPiece = null;
	}
	showMoves = [];
	showCaptures = [];
	draw();

	if (NextButton.disabled && (phase == 1)) {
		NextButton.disabled = (playerPieces[0].x != 6) || (playerPieces[0].y != 7);
	}
};

function moveToFront(item, list) {
	list.splice(list.indexOf(item), 1);
	list.push(item);
}

Board.onmousedown = function() {
	event.preventDefault();
	mouseDown = true;
	var x = mouseX;
	var y = mouseY;
	var piece = pieceUnderMouse();
	if (piece != null) {
		if ((playerOwns(piece) || (phase == 8)) &&
				((moveLimit == 0) || (moveCount < moveLimit))) {
			movingPiece = piece;
			movingPieceX = hexPosX(piece.x, piece.y) + squareSize/2;
			movingPieceY = hexPosY(piece.x, piece.y) + squareSize/2;
			grabX = x - movingPieceX;
			grabY = y - movingPieceY;
			moveToFront(piece, (playerOwns(piece) ? playerPieces : opponentPieces));
		}
		showMoves = getMoves(piece);
		showCaptures = getCaptures(piece);
	}
	draw();
};


// Interface

var resetCount = 0;

PreviousButton.onclick = function() {
	resetCount = 0;
	setPhase(phase - 1);
}

ResetButton.onclick = function() {
	if (++resetCount >= 2) {
		HintText.style.display = "inline";
	}
	setPhase(phase);
}

NextButton.onclick = function() {
	resetCount = 0;
	setPhase(phase + 1);
}


// Draw terrain thumbnails.

drawTerrainThumbails();


// Ensure art is loaded.

var artLoaded = 0;

function beginIfArtLoaded() {
    if (++artLoaded == pieceArt.length) {
	    setPhase(1);
    }
}

for (var i = 0; i < pieceArt.length; ++i) {
    var image = pieceArt[i];
    if (image.complete && (image.naturalWidth > 0))  {
        ++artLoaded;
    } else {
        pieceArt[i].onload = beginIfArtLoaded;
    }
}
if (artLoaded == pieceArt.length) {
    setPhase(1);
} else {
    setPhase(0);
}

</script>
</body>
</html>